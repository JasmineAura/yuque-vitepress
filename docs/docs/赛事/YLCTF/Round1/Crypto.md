# signrsa
```python

import libnum
from Crypto.Util.number import *
fp = open("/flag","r")
flag = fp.read()
fp.close()
m = bytes_to_long(bytes(flag.encode()))
n1 = 18674375108313094928585156581138941368570022222190945461284402673204018075354069827186085851309806592398721628845336840532779579197302984987661547245423180760958022898546496524249201679543421158842103496452861932183144343315925106154322066796612415616342291023962127055311307613898583850177922930685155351380500587263611591893137588708003711296496548004793832636078992866149115453883484010146248683416979269684197112659302912316105354447631916609587360103908746719586185593386794532066034112164661723748874045470225129298518385683561122623859924435600673501186244422907402943929464694448652074412105888867178867357727
n2 = 20071978783607427283823783012022286910630968751671103864055982304683197064862908267206049336732205051588820325894943126769930029619538705149178241710069113634567118672515743206769333625177879492557703359178528342489585156713623530654319500738508146831223487732824835005697932704427046675392714922683584376449203594641540794557871881581407228096642417744611261557101573050163285919971711214856243031354845945564837109657494523902296444463748723639109612438012590084771865377795409000586992732971594598355272609789079147061852664472115395344504822644651957496307894998467309347038349470471900776050769578152203349128951
e = 65537
c = pow(m,e,n1)
c = pow(c,e,n2)
print(c)


```

其实就是两次 RSA，n1,n2 都能分出来，直接正常打即可。

```python
import libnum
n1 = 18674375108313094928585156581138941368570022222190945461284402673204018075354069827186085851309806592398721628845336840532779579197302984987661547245423180760958022898546496524249201679543421158842103496452861932183144343315925106154322066796612415616342291023962127055311307613898583850177922930685155351380500587263611591893137588708003711296496548004793832636078992866149115453883484010146248683416979269684197112659302912316105354447631916609587360103908746719586185593386794532066034112164661723748874045470225129298518385683561122623859924435600673501186244422907402943929464694448652074412105888867178867357727
n2 = 20071978783607427283823783012022286910630968751671103864055982304683197064862908267206049336732205051588820325894943126769930029619538705149178241710069113634567118672515743206769333625177879492557703359178528342489585156713623530654319500738508146831223487732824835005697932704427046675392714922683584376449203594641540794557871881581407228096642417744611261557101573050163285919971711214856243031354845945564837109657494523902296444463748723639109612438012590084771865377795409000586992732971594598355272609789079147061852664472115395344504822644651957496307894998467309347038349470471900776050769578152203349128951
e = 65537
p1=122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137
q1=152715809540018210476585794506755656304018419053948315845024020442944919163424223089911596424947890322440115812073982242024003568582438886041563636295260718520579341235023201649280953992781776747918771204104127874320443126139004728988091615072560392886456699262578469698870106391640100933195833135586571108071
p2=122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137
q2=164145170653883024647553629463737123010827979171828830103523021501297388761756036648096075592988518245508893542122459154529428778971624332785030551503124716064026198761937539065927958768419405758793987137195172361163960622671936646689220816452043219075732911538605192466301352357559388894114979459113315335423
c = 635502215724372215931456844419152571480462147936723982503459361998618647668072315561987104631739529947533067093973485593859152220243528241512819236636536341840702073778138605205396414952585694028481170235066429345922467807345664346656926018609253142120184327501815294668727941667972416555355858410662105782227415166829071065399605216400913995623236899757078037943704724284689323758126447459094260720114675682302434123763837255474180568756536364397360341200448917341125271498744879653938983320667232081363495628001418168936100331073324991153620042259074769255623065851740103333380201768667181194475176478812466731729
phi2 = (p2-1)*(q2-1)
d2 = libnum.invmod(e,phi2)
c = pow(c,d2,n2)
phi = (p1-1)*(q1-1)
d1 = libnum.invmod(e,phi)
m = pow(c,d1,n1)
print(libnum.n2s(m))
#b'YLCTF{7d170960-18e1-4361-aadf-85a38af0fa23}\n'


```

# BREAK
```python
from Crypto.Util.number import *
from flag import FLAG
import random
from gmpy2 import *
p = getPrime(1024)
q = getPrime(1024)
n = p * q
phi = (p-1) * (q-1)
e = random.randint(55555,66666)
while (GCD(e,phi) != 1):
    e = random.randint(55555,66666)
d = invert(e, phi)
m = bytes_to_long(FLAG.encode())
c = pow(m,e,n)
with open('1.txt','w') as f:
    f.write("c = " + str(c)+"\n")
    f.write("p = " + str(p)+"\n")
    f.write("q = " + str(q)+"\n")



```

e 不知道，但是范围很小，直接爆破，然后走正常 RSA。

```python
import libnum
from tqdm import trange
c = 2924474039245207571198784141495689937992753969132480503242933533024162740004938423057237165017818906240932582715571015311615140080805023083962661783117059081563515779040295926885648843373271315827557447038547354198633841318619550200065416569879422309228789074212184023902170629973366868476512892731022218074481334467704848598178703915477912059538625730030159772883926139645914921352787315268142917830673283253131667111029720811149494108036204927030497411599878456477044315081343437693246136153310194047948564341148092314660072088671342677689405603317615027453036593857501070187347664725660962477605859064071664385456
p = 112201812592436732390795120344111949417282805598314874949132199714697698933980025001138515893011073823715376332558632580563147885418631793000008453933543935617128269371275964779672888059389120797503550397834151733721290859419396400302434404551112484195071653351729447294368676427327217463094723449293599543541
q = 177020901129489152716203177604566447047904210970788458377477238771801463954823395388149502481778049515384638107090852884561335334330598757905074879935774091890632735202395688784335456371467073899458492800214225585277983419966028073512968573622161412555169766112847647015717557828009246475428909355149575012613
n = p * q
phi = (p-1) * (q-1)

for e in trange(55555,66667):
    if libnum.gcd(e,phi)!=1:
        continue
    d = libnum.invmod(e,phi)
    m = pow(c,d,n)
    flag = libnum.n2s(m)
    if b'YLCTF' in flag:
        print(flag)
        break
#80%|████████  | 8944/11112 [01:16<00:18, 116.39it/s]
#b'YLCTF{fbb6186c-6603-11ef-ba80-deb857dc15be}'


```



# r(A)=3
先手玩一下，大概就是给 300 个三元一次方程组，解出来 x,y,z 然后提交。

```plain
function1:
5*x + 2*y + -4*z = -635
1*x + 3*y + -1*z = 258
8*x + 5*y + 1*z = 27
input x=



```

需要使用 pwntools，把系数用正则表达式提取出来，然后用 z3 求解器去解。

```python
#!/usr/bin/env python
# coding=utf-8
from pwn import *
import re
import z3
import string
context.log_level='debug'
io = remote("challenge.yuanloo.com",49483)
pattern = r'-?\d+(?=\*[x,y,z])i'
for i in range(300):
    io.recvuntil(b':\n')
    a = [0,0,0]
    b = [0,0,0]
    c = [0,0,0]
    f = [0,0,0]
    for i in range(3):
        equation = io.recvline().decode()
        print(equation)
        match = re.findall(r'[+-]?\d+', equation)
        print(match)
        if match:
            a[i] = match[0]
            b[i] = match[1]
            c[i] = match[2]
            f[i] = match[3]
        print(a[i])
        print(b[i])
        print(c[i])
        print(f[i])
        print('----------')
    s = z3.Solver()
    x,y,z = z3.Ints('x y z')
    for i in range(3):
        s.add(x*a[i]+y*b[i]+z*c[i]==f[i])
    s.check()
    print(s.model())
    io.sendline(str(s.model()[x]))
    io.sendline(str(s.model()[y]))
    io.sendline(str(s.model()[z]))
io.interactive()



```



# ezrsa
```python

import libnum
from Crypto.Util.number import *
fp = open("/flag","r")
flag = fp.read()
fp.close()
m = libnum.s2n(flag)
p = libnum.generate_prime(512)
q = libnum.generate_prime(512)
e = 65537
n = p * q
h = 20240918
yl = bytes_to_long(b"YLCTF")
hint = pow(h + p * yl, e, n)
c = pow(m, e, n)
print("hint=", hint)
print("n=", n)
print("c=", c)

hint= 6534644468948771801247214888192019389563830150652852829224295651862519287056207691082457644396858861995933207045157702487568371002010847012320648385613218849910756331346422059531645786530279016320097148617461545422180712974204915133698193741667124048275574540863764524005818715469608728780303134846264525
n= 72897772844361484812455950155672860784063188983808256838580326531618149082563349775214077631960991882079772957651260106176774194815536511794769964098839631082481119816830530862785825032610906912971172981856054770316629782039295851841446550911964299028999865330613845697295034702677222109139809852218937844513
c= 14842270733991544060058433292375924392731799362365922515908080194771224028963674017880207875982661409531759104689134776503721722894822504736114038506283246992755596489552151809374433698291743094387053618360127404170819972975690526442298415543272403135421001116273756205626379495301036246380413863236540215120



```

![image](../../../../images/085db813c438151262229412aadd0d2f.svg)

也就是说 `p=gcd(pow(h,e,n)-hint,n)`

```python
import libnum
from Crypto.Util.number import *
h = 20240918
yl = bytes_to_long(b"YLCTF")
e = 65537
hint= 86209219350931172673703461070839725693749813176070953976913813417422866517648950628974769491760985591318397080786295707907976999582744206362001511274616920752861030660408570602874750281303281753975230818347680612069162769595535484636458665791138809690571124799577833378546093090718811428642066459327268329002
n= 90200542688397473947616288942457182284446943842919406993061049979713514670718075371781854294848501192172405082679895157870639555323407500057226653460983166232799997666166906793775613209991095936313533296192221497648492675257617999394559698642885477095688105530141563193959013415606463622924720875646965688013
c= 4741099192560508670954802686083416391036616590809245405331743126913221076758220820303993990875542089565013500138808577801351260090032217764373253029045265936952277554284105055084635952084081923326186760096589749102547382415504026331002897353113815988275297287178728867759840474626944107357424089652273724246
p = libnum.gcd(pow(h,e,n)-hint,n)
q = n//p
phi = (p-1)*(q-1)
d = libnum.invmod(e,phi)
m = pow(c,d,n)
print(libnum.n2s(m))
#b'YLCTF{8c5666d8-4465-43b0-aa36-b070a139baa9}\n'



```

# threecry
```python

from Crypto.Util.number import *
import sympy
fp = open("/flag","r")
flag = fp.read()
fp.close()
a=getPrime(512)
p=sympy.nextprime(13*a)
q=sympy.prevprime(25*a)
number2=p*q

def crypto01(number1, number2, number3):
    number4 = 1
    while number2 > 0:
        if number2 % 2:
            number4 = (number4 * number1) % number3
        number1 = number1 ** 2 % number3
        number2 //= 2
    return number4

def crypto02(number1, number2):
    number3 = number1
    number4 = number2
    giao = 1
    giaogiao = 0
    while number4 > 0:
        number7 = number3 // number4
        giao, giaogiao = giaogiao, giao - giaogiao*number7
        number3, number4 = number4, number3 - number4*number7
    while giao<0:
        giao = giao + number2
    return giao

def crypto03(number1, number2, number3):
    number4 = crypto01(number3, number1, number2)
    return number4

def crypto05(number1,number2):
    return pow(number1,0xe18e,number2)






number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683
number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
number3 = int.from_bytes(flag[0:19].encode("utf-8"), "big")
number4 = int.from_bytes(flag[19:].encode("utf-8"), "big")
print(number2)
print(crypto03(number1, number2, number3))
print(crypto05(number4,number2))

number2= 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
crypto03= 19314672557142329600978979180148216066727150421428158927781981400364673930760934134552604813832526320840697972014826482411548284799416147221841666539702679999594418822248453084629783493095648387349041046624593477120815889826162461374545498612669379038335173574991876218284827023677859258012940244631526369124879
crypto05= 2541148112550118662523688907635260067492267801609157520600811898236258675196425539375613496139996682759981168884546377157301550252364767834296971661585667409820558783914877346494232707603877930223232832490265908778046111181187512283712689452054193477663802077383135861165906658503532007145623127302680574496540



```

很长很乱，先耐心分析一下。

发现 crypto01 其实就是个快速幂，也就是和 pow 函数等价的。

crypto02 函数根本没用到，直接忽略。

其实就是把 flag 分成两块加密，都是正常的 RSA，![image](../../../../images/497bc8ddea5b26b7af8dd0f9033d914b.svg)就是 number2。

![image](../../../../images/497bc8ddea5b26b7af8dd0f9033d914b.svg)可以近似成 ![image](../../../../images/93ba55f13ae91c8503dee70cbb043fc5.svg)，也就是 ![image](../../../../images/ebc8dbd7fce5ad2d71f99a53006cdc15.svg)和 ![image](../../../../images/bcaf00ea3b2f355b1f73a140a920d63b.svg)很接近。

左右移动一下，就能得到正确的 ![image](../../../../images/283ef708f8357d5a485e425960066b3c.svg)和 ![image](../../../../images/f4d1a6f2265ec40e4020518d7699307b.svg)。

然后就是解正常的 RSA，第一部分能直接解出来，第二部分是一个 ![image](../../../../images/927181945ac6a9190ce405b9f235bdd1.svg)，![image](../../../../images/83757fccc0aec3e7089a46c4225aa9f0.svg)不互素，跑个板子就行。

```python
import sympy
import libnum
number1 = 6035830951309638186877554194461701691293718312181839424149825035972373443231514869488117139554688905904333169357086297500189578624512573983935412622898726797379658795547168254487169419193859102095920229216279737921183786260128443133977458414094572688077140538467216150378641116223616640713960883880973572260683
number2 = 20163906788220322201451577848491140709934459544530540491496316478863216041602438391240885798072944983762763612154204258364582429930908603435291338810293235475910630277814171079127000082991765275778402968190793371421104016122994314171387648385459262396767639666659583363742368765758097301899441819527512879933947
crypto03= 19314672557142329600978979180148216066727150421428158927781981400364673930760934134552604813832526320840697972014826482411548284799416147221841666539702679999594418822248453084629783493095648387349041046624593477120815889826162461374545498612669379038335173574991876218284827023677859258012940244631526369124879
crypto05= 2541148112550118662523688907635260067492267801609157520600811898236258675196425539375613496139996682759981168884546377157301550252364767834296971661585667409820558783914877346494232707603877930223232832490265908778046111181187512283712689452054193477663802077383135861165906658503532007145623127302680574496540
afang = number2//325
a = libnum.nroot(afang,2)
a = sympy.prevprime(a)
p=sympy.nextprime(13*a)
q=sympy.prevprime(25*a)
assert p*q==number2
phi = (p-1)*(q-1)
d = libnum.invmod(number1,phi)
m1 = pow(crypto03,d,number2)
#print(libnum.n2s(m1))
e = 0xe18e
t = libnum.gcd(e,phi)
print(t)
e1 = e//t
d = libnum.invmod(e1,phi)
mt = pow(crypto05,d,number2)
m2 = libnum.nroot(mt,2)
print(libnum.n2s(m1)+libnum.n2s(m2))
#2
#b'YLCTF{4f734dea-2b1c-4079-8f09-4ff9882cf612}\n'



```

