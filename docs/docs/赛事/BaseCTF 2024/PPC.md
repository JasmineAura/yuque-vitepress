é˜Ÿä¼ï¼š<font style="background-color:rgba(255, 255, 255, 0);">Aura&Jumping</font>

## <font style="color:rgb(107, 0, 64);">P</font><font style="color:rgb(0, 54, 111);">PC</font>
### BaseCTF å´©å•¦ - å¯¼è¨€
å¦‚é¢˜ï¼Œä¸‹è½½å¥½é™„ä»¶ååœ¨ README.txt ä¸­å‘ç° flagã€‚

### BaseCTF å´©å•¦ II - è¿‡æœŸäº†?
è¦æ±‚æ‰¾åˆ° `Damien Schroeder` é˜Ÿä¼çš„æ‰€æœ‰é€¾æœŸæäº¤é¢˜ç›®ï¼Œå¹¶æŒ‰ç…§æ—¶é—´é¡ºåºç”¨è‹±æ–‡é€—å·è¿æ¥ï¼Œå– md5 å€¼ã€‚

çœ‹äº†ä¸€ä¸‹ï¼Œæ‰€æœ‰é¢˜ç›®çš„æˆªæ­¢æäº¤æ—¶é—´éƒ½ä¸º 2024-08-31T15:00:00+08:00ï¼Œä¹Ÿå°±æ˜¯æ‰¾è¯¥é˜Ÿä¼ 2024.8.31 15:00:00 åçš„æ‰€æœ‰æäº¤è®°å½•ï¼Œæ‰¾åˆ°ä»¥åé€šè¿‡é¢˜ç›®åç§°å»å¯¹åº”é¢˜ç›®çš„ Idï¼Œæ’åºä»¥åæ˜¯è¿™æ ·ã€‚

:::info
[2024/8/31 16:09:34 +08:00 INF] 8bcad0d3-6379-411f-5edb-650c20f30dd5



[2024/8/31 17:38:58 +08:00 INF] 563c8303-5eb1-affe-1369-e8889b9323eb



[2024/8/31 18:07:48 +08:00 INF]  ef0a3095-ece1-c427-ab20-99a79fe10bc8



[2024/8/31 18:30:22 +08:00 INF] 2ac9055a-1a79-857f-ed12-e33e5acdc9a3



[2024/8/31 20:28:55 +08:00 INF]  063c3506-d3e4-668b-88f7-2da39092dfe0



[2024/8/31 23:33:54 +08:00 INF] b18048d0-bd8e-0fd0-22b3-61780bae1608

:::

æŒ‰ç…§è¦æ±‚æ‹¼æ¥åé•¿è¿™æ ·ã€‚

:::info
8bcad0d3-6379-411f-5edb-650c20f30dd5,563c8303-5eb1-affe-1369-e8889b9323eb,ef0a3095-ece1-c427-ab20-99a79fe10bc8,2ac9055a-1a79-857f-ed12-e33e5acdc9a3,063c3506-d3e4-668b-88f7-2da39092dfe0,b18048d0-bd8e-0fd0-22b3-61780bae1608

:::

md5 åå¥—ä¸Š BaseCTF å°±æ˜¯ flagã€‚

### BaseCTF å´©å•¦ III - å¸®æˆ‘æŸ¥æŸ¥é˜Ÿä¼çš„è§£é¢˜
æ¯”èµ·ä¸Šä¸€é¢˜ï¼Œæ‰‹åŠ¨å»åšæ˜¾å¾—æ›´åƒåŠ›ï¼Œæ‰€ä»¥éœ€è¦å€ŸåŠ©ä¸€ä¸‹è„šæœ¬ã€‚

å¤§è‡´æ„æ€å°±æ˜¯æ‰¾åˆ°  Rick Hyatt  é˜Ÿä¼æ‰€æœ‰æœªæäº¤ï¼Œæäº¤é”™è¯¯ï¼Œæˆ–è€…é€¾æœŸæäº¤çš„æ‰€æœ‰é¢˜ç›®ï¼ŒæŒ‰ç…§ challenges.json ä¸­çš„é¢˜ç›®é¡ºåºæ‹¼æ¥ï¼Œå– md5 å€¼ã€‚

æ­£éš¾åˆ™åï¼Œæˆ‘ä»¬æŠŠè¯¥é˜Ÿä¼æ‰€æœ‰æäº¤æ­£ç¡®çš„é¢˜ç›®æ‰¾å‡ºæ¥ï¼Œç„¶åæŠŠè¿™äº›é¢˜ç›®ä½œä¸ºé»‘åå•ï¼Œç”¨è„šæœ¬è·‘ä¸€ä¸‹ï¼Œè‡ªç„¶å°±èƒ½å¾—åˆ°æƒ³è¦çš„é‚£äº›é¢˜ç›®ã€‚

å¯ä»¥æ‰‹åŠ¨æŠŠè¯¥é˜Ÿä¼çš„æäº¤è®°å½•éƒ½å–å‡ºæ¥ï¼Œå…ˆåˆ æ‰é€¾æœŸæäº¤çš„é¢˜ç›®ï¼Œå†å»çœ‹å‰©ä½™çš„é¢˜ç›®æ˜¯å¦æœ‰æäº¤é”™è¯¯çš„ã€‚

æ€ä¹ˆçœ‹æäº¤æ˜¯å¦æ­£ç¡®ï¼Œè¿™é‡Œéœ€è¦å…ˆå»çœ‹ teams.jsonï¼Œæ‰¾åˆ°è¯¥é˜Ÿä¼çš„ Idï¼Œç„¶ååœ¨ flags.json æŠŠè¯¥é˜Ÿä¼çš„ flag æå‡ºæ¥ï¼Œä¾æ¬¡å¯¹æ¯”å³å¯ã€‚

æœ€ååªæœ‰ 3 ä¸ªé¢˜ç›®æäº¤æ­£ç¡®ï¼ŒæŠŠä»–ä»¬å†™å…¥ä¸€ä¸ª black.txtï¼Œä½œä¸ºé»‘åå•ã€‚

```plain
[[Week2] Aura é…±çš„æ—…è¡Œæ—¥è®° VI <å›¾å¯»æ“‚å°>]
[[Week3] ä½ ä¸ºä»€ä¹ˆä¸è®©æˆ‘æº¢å‡º]
[[Week2] try_to_factor]
```

æ¥ä¸‹æ¥ç”¨è„šæœ¬è·‘ï¼ŒæŠŠæ‰€æœ‰æœªåœ¨é»‘åå•ä¸­çš„é¢˜ç›®çš„ Id æ‹¼å‡ºæ¥å³å¯ã€‚

```python
import json
from hashlib import md5
with open('black.txt', 'r', encoding='utf-8') as file:
    blacklist = file.read()
with open('challenges.json', 'r') as file:
    data = json.load(file)
ids_to_output = []
cnt = 0
for item in data:
    if item['Name'] not in blacklist:
        ids_to_output.append(item['Id'])
        cnt += 1
output_ids = ','.join(ids_to_output)
print(output_ids)
print(cnt)
print(md5(output_ids.encode('utf-8')).hexdigest())
```

æœ€ç»ˆ md5 å€¼ï¼š4f87919032dfc58a9a23044aab9acd99ã€‚

åŒ…ä¸Š BaseCTF å°±æ˜¯ flagã€‚

### BaseCTF å´©å•¦ IV - æ’æ’ååƒæœæœ
ç»Ÿè®¡æ’åï¼Œç»†èŠ‚å¾ˆå¤šã€‚

+ è¶…æ—¶æäº¤çš„ä¸è®¡åˆ†
+ 0 åˆ†çš„é˜Ÿä¼ä¹Ÿè¦è®¡ç®—åˆ°æ’åä¸­ï¼Œä½†æœ‰å¯èƒ½è¿™ç±»é˜Ÿä¼å°±æ²¡æäº¤è®°å½•ï¼Œéœ€è¦ä» teams.json é‡Œé¢åˆå§‹åŒ–
+ æœ‰çš„é˜Ÿä¼ä¼šé‡å¤æäº¤æ­£ç¡®çš„ flagï¼Œåˆ†æ•°ä¸èƒ½é‡å¤ç´¯åŠ 
+ æœ‰ä¸ªé‡åçš„é˜Ÿä¼ï¼Œä¸è¿‡å‡ºé¢˜äººå¾ˆè‰¯å¿ƒï¼ŒæŠŠè¿™ä¸ªé‡åé˜Ÿä¼çš„å¾—åˆ†åˆå¹¶ä¹Ÿè§†ä¸ºæ­£ç¡®ç­”æ¡ˆ

ä¸ºäº†æ–¹ä¾¿ä¹¦å†™è®¡ç®—ä»£ç ï¼Œè¿™é‡ŒæŠŠ submissions.log é€šè¿‡è„šæœ¬è½¬æˆäº† submit.jsonï¼ŒåŒæ—¶å¿½ç•¥äº†è¶…æ—¶æäº¤çš„è®°å½•ã€‚

```python
import re
from datetime import datetime
import json
comparison_time_str = "2024-08-31T15:00:00+08:00"
comparison_time = datetime.fromisoformat(comparison_time_str)
with open('submissions.log', 'r') as f:
    log_entries = f.read()
log_entries = log_entries.split('\n')
logs = []
def extract_info(log_line):
    patterns = {
        'time': r'\[(.*?)\]',
        'team': r'é˜Ÿä¼ \[(.*?)\]',
        'challenge': r'æäº¤é¢˜ç›® \[(.*?)\] çš„ç­”æ¡ˆ',
        'flag': r'ç­”æ¡ˆ \[(.*?)\]'
    }
    extracted_info = {key: re.search(pattern, log_line).group(1) if re.search(pattern, log_line) else None
                      for key, pattern in patterns.items()}
    return extracted_info
for log in log_entries:
    log_json = extract_info(log)
    if log_json['time']:
        log_json['time'] = time = datetime.strptime(log_json['time'][:-4], '%Y/%m/%d %H:%M:%S %z')
        if log_json['time'] <= comparison_time:
            log_json.pop('time', None)
            logs.append(log_json)
def save_to_json(data, filename):
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=True, indent=3)
save_to_json(logs, 'submit.json')
```

ç”Ÿæˆäº† submit.json ä»¥åï¼Œæ¥ä¸‹æ¥å°±æ˜¯ç»Ÿè®¡æ’åï¼Œéœ€è¦æŠŠä¹‹å‰çš„ç»†èŠ‚éƒ½è€ƒè™‘åˆ°ã€‚

å¯¹äºé‡å¤æäº¤æ­£ç¡® flag çš„é˜Ÿä¼ï¼Œè¿™é‡Œä½¿ç”¨ vis å­—å…¸è¿›è¡Œæ‰“æ ‡è®°ï¼Œæœªæ‰“æ ‡è®°çš„æ­£å¸¸åŠ åˆ†ï¼Œæ‰“è¿‡æ ‡è®°çš„ä¸å†è®¡åˆ†ã€‚

```python
import json
import hashlib
from tqdm import tqdm
with open('challenges.json', 'r') as f:
    json_string = f.read()
challenges = json.loads(json_string)
with open('flags.json', 'r') as f:
    json_string = f.read()
flags = json.loads(json_string)
with open('teams.json', 'r') as f:
    json_string = f.read()
teams = json.loads(json_string)
with open('submit.json', 'r') as f:
    json_string = f.read()
submits = json.loads(json_string)
scores = {}
vis = {}
for team in teams:
    scores[team['Name']] = 0
    vis[team['Name']] = {}
    for problem in challenges:
        vis[team['Name']][problem['Id']] = False
for submit in tqdm(submits, desc="Processing submits"):
    sub_team = submit['team']
    sub_flag = submit['flag']
    sub_challenge = submit['challenge']
    challenge = next((item for item in challenges if item['Name'] == sub_challenge), None)
    points = challenge['Points']
    challenge_id = challenge['Id']
    team = next((item for item in teams if item['Name'] == sub_team), None)
    team_id = team['Id']
    if vis[sub_team][challenge_id]:
        continue
    flag = next((item for item in flags if (item['ChallengeId'] == challenge_id and item['TeamId'] == team_id)), None)
    if flag['Flag'] == sub_flag:
        vis[sub_team][challenge_id] = True
        scores[sub_team] += points
def sort_and_generate_flag(data):
    sorted_data = sorted(data.items(), key=lambda x: (-x[1], x[0]))
    concatenated_string = ';'.join(f"{team},{points}" for team, points in sorted_data)
    print(concatenated_string)
    md5_result = hashlib.md5(concatenated_string.encode('utf-8')).hexdigest()
    flag = f"BaseCTF{{{md5_result}}}"
    return flag
print(sort_and_generate_flag(scores))
```



### BaseCTF å´©å•¦ V - æ­£ä¹‰æ‰§è¡Œ!
ç»Ÿè®¡ä½œå¼Šé˜Ÿä¼ï¼Œåªè¦æäº¤å…¶ä»–é˜Ÿä¼ Flag éƒ½è§†ä¸ºä½œå¼Šã€‚

éœ€è¦å°†ä¹‹å‰è½¬ json çš„è„šæœ¬ä¿®æ”¹ä¸€ä¸‹ï¼ŒæŠŠæ—¶é—´è¿‡æ»¤åˆ å»å³å¯ã€‚

```python
import re
import json
with open('submissions.log', 'r', encoding='utf-8') as f:
    log_entries = f.read()
log_entries = log_entries.split('\n')
logs = []
def extract_info(log_line):
    patterns = {
        'time': r'\[(.*?)\]',
        'team': r'é˜Ÿä¼ \[(.*?)\]',
        'challenge': r'æäº¤é¢˜ç›® \[(.*?)\] çš„ç­”æ¡ˆ',
        'flag': r'ç­”æ¡ˆ \[(.*?)\]'
    }
    extracted_info = {key: re.search(pattern, log_line).group(1) if re.search(pattern, log_line) else None
                      for key, pattern in patterns.items()}
    return extracted_info
for log in log_entries:
    log_json = extract_info(log)
    logs.append(log_json)
def save_to_json(data, filename):
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=True, indent=3)
save_to_json(logs, 'submit.json')

```

ç»Ÿè®¡ä½œå¼Šé˜Ÿä¼ä¹Ÿæœ‰ä¸€äº›å°ç»†èŠ‚ã€‚

+ æœ€åè¦çš„æ˜¯æœªä½œå¼Šçš„é˜Ÿä¼
+ æœ‰å¯èƒ½æœ‰çš„é˜Ÿä¼äº¤äº†å¤šä¸ªå…¶å®ƒé˜Ÿä¼çš„ flag
+ åªè¦äº¤äº†å…¶å®ƒé˜Ÿä¼çš„ flagï¼Œä¸ç®¡æ˜¯å“ªä¸ªé¢˜ï¼ŒåŒæ–¹éƒ½è§†ä¸ºä½œå¼Š

```python
import json
import hashlib
from pwnlib.dynelf import sizeof
from tqdm import tqdm
with open('challenges.json', 'r') as f:
    json_string = f.read()
challenges = json.loads(json_string)
with open('flags.json', 'r') as f:
    json_string = f.read()
flags = json.loads(json_string)
with open('teams.json', 'r') as f:
    json_string = f.read()
teams = json.loads(json_string)
with open('submit.json', 'r') as f:
    json_string = f.read()
submits = json.loads(json_string)
cheaters = []
all_teams = []
for team in teams:
    all_teams.append(team['Id'])
for submit in tqdm(submits, desc="Processing submits"):
    sub_team = submit['team']
    sub_flag = submit['flag']
    sub_challenge = submit['challenge']
    # challenge = next((item for item in challenges if item['Name'] == sub_challenge), None)
    # challenge_id = challenge['Id']
    team = next((item for item in teams if item['Name'] == sub_team), None)
    team_id = team['Id']
    flag = next((item for item in flags if (item['Flag'] == sub_flag)), None)
    if flag is None:
        continue
    if flag['TeamId']!=team_id:
        if team_id not in cheaters:
            cheaters.append(team_id)
        if flag['TeamId'] not in cheaters:
            cheaters.append(flag['TeamId'])

print(cheaters)
def sort_and_generate_flag():
    temp = []
    for team in all_teams:
        if team in cheaters:
            continue
        temp.append(team)
    ans = []
    for id in temp:
        team = next((item for item in teams if item['Id'] == id), None)
        ans.append(team['Name'])
    ans.sort()
    concatenated_string = ','.join(team for team in ans)
    print(concatenated_string)
    md5_result = hashlib.md5(concatenated_string.encode('utf-8')).hexdigest()
    flag = f"BaseCTF{{{md5_result}}}"
    return flag
print(sort_and_generate_flag())
```

:::color4
Addie Will,Amber Powlowski,Annabelle Treutel,Camilla Halvorson,Candice Rempel,Einar Langosh,Gerson Reynolds,Guy Stiedemann,Jackson Beatty,Janiya Boehm,Jasen Weimann,Jewel Mohr,Kathlyn Wintheiser,Lexie O'Conner,Marquis Metz,Mikayla Lubowitz,Molly Rodriguez,Nellie Purdy,Queenie Franecki,Rick Auer,Rosendo Jenkins,Tess Koelpin,Wilhelmine Smith

:::

ğŸ‘†æ‰€æœ‰æœªä½œå¼Šçš„é˜Ÿä¼ï¼ˆæŒ‰é˜Ÿåå­—å…¸åºæ’åºï¼‰



